class BinaryTreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
def merge_two_binary_search_trees(root1, root2):
    """
    Args:
     root1(BinaryTreeNode_int32)
     root2(BinaryTreeNode_int32)
    Returns:
     BinaryTreeNode_int32
    """
    if root1 is None and root2 is None:
        return None
    if root1 is None:
        return root2
    if root2 is None:
        return root1

    aux_merge = []
    array1 = []
    array2 = []

    def dfs(node, arr):
        if node.left is not None:
            dfs(node.left)
        arr.append(node.value)
        if node.right is not None:
            dfs(node.right)

    dfs(root1, array1)
    dfs(root2, array2)

    def merge_fun():
        i, j = 0, 0
        while i < len(array1) and j < len(array2):
            if array1[i] <= array2[j]:
                aux_merge.append(array1[i])
                i += 1
            else:  # array1[i] > array2[j]
                aux_merge.append(array2[j])
                j += 1
        while i < len(array1):
            aux_merge.append(array1[i])
            i += 1
        while j < len(array2):
            aux_merge.append(array2[j])
            j += 1

    merge_fun()

    def tree_Construction(start, end):
        if start > end:
            return None

        mid = start + (end - start) // 2
        root = BinaryTreeNode(aux_merge[mid])
        # left
        root.left = tree_Construction(start, mid - 1)
        root.right = tree_Construction(mid + 1, end)
        return root

    return tree_Construction(0, len(aux_merge - 1))